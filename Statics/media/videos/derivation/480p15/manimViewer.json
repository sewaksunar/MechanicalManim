{
    "StressTransformation": "class StressTransformation(Scene):\n    def construct(self):\n        theta = PI / 3\n        side = 3\n        txx, tyy, txy = 1.5, 1.0, 1.2\n        offset = 0.2\n        p_origin = ORIGIN\n        p_right = RIGHT * side\n        p_top = UP * (side * np.tan(theta))\n        wedge = Polygon(p_origin, p_right, p_top, color=WHITE, stroke_width=2)\n        wedge.set_fill(GRAY, opacity=0.3)\n        hyp_mid = (p_right + p_top) / 2\n        normal_dir = rotate_vector(RIGHT, theta)\n        tangent_dir = rotate_vector(UP, theta)\n        s_n = Arrow(hyp_mid, hyp_mid + normal_dir * 1.5, buff=0, color=RED)\n        t_nt = Arrow(hyp_mid, hyp_mid + tangent_dir * 1.2, buff=0, color=MAROON)\n        l_sn = MathTex(r\"\\sigma_n\").next_to(s_n, normal_dir, buff=0.1)\n        l_tnt = MathTex(r\"\\tau_{nt}\").next_to(t_nt, tangent_dir, buff=0.1)\n        s_xx_v = Arrow(p_origin + LEFT*offset, p_origin + LEFT*(txx+offset), buff=0, color=YELLOW)\n        s_xx_v.shift(UP * (p_top[1]/2))\n        l_xx = MathTex(r\"\\sigma_{xx}\").next_to(s_xx_v, LEFT)\n        s_yy_h = Arrow(p_origin + DOWN*offset, p_origin + DOWN*(tyy+offset), buff=0, color=YELLOW)\n        s_yy_h.shift(RIGHT * (side/2))\n        l_yy = MathTex(r\"\\sigma_{yy}\").next_to(s_yy_h, DOWN)\n        tau_h = Arrow(p_origin + DOWN*offset*2, p_origin + DOWN*offset*2 + RIGHT*1.5, buff=0, color=BLUE)\n        tau_h.shift(RIGHT * (side/2 - 0.75))\n        arc = Arc(radius=0.7, start_angle=0, angle=theta, arc_center=p_right)\n        l_theta = MathTex(r\"\\theta\").next_to(arc, LEFT, buff=0.1).scale(0.8)\n        eq = MathTex(\n            r\"\\sigma_n = \\sigma_x \\cos^2\\theta + \\sigma_y \\sin^2\\theta + 2\\tau_{xy}\\sin\\theta\\cos\\theta\"\n        ).scale(0.7).to_edge(DOWN)\n        derivation = VGroup(wedge, s_n, t_nt, l_sn, l_tnt, s_xx_v, l_xx, s_yy_h, l_yy, tau_h, arc, l_theta)\n        derivation.move_to(ORIGIN).scale(0.9)\n        self.add(derivation, eq)",
    "StressTransformationDerivation": "class StressTransformationDerivation(Scene):\n    def construct(self):\n        theta = PI / 3\n        side = 3\n        txx, tyy, txy = 1.5, 1.0, 1.2\n        offset = 0.2\n        p_origin = ORIGIN\n        p_right = RIGHT * side\n        p_top = UP * (side * np.tan(theta))\n        wedge = Polygon(p_origin, p_right, p_top, color=WHITE, stroke_width=2)\n        wedge.set_fill(GRAY, opacity=0.3)\n        s_line = Line(p_right, p_top, color=RED, stroke_width=4)\n        hyp_mid = (p_right + p_top) / 2\n        normal_dir = rotate_vector(RIGHT, theta)\n        tangent_dir = rotate_vector(UP, theta)\n        s_n = Arrow(hyp_mid, hyp_mid + normal_dir * 1.5, buff=0, color=RED)\n        t_nt = Arrow(hyp_mid, hyp_mid + tangent_dir * 1.2, buff=0, color=MAROON)\n        l_sn = MathTex(r\"\\sigma_n\").next_to(s_n, normal_dir, buff=0.1)\n        l_tnt = MathTex(r\"\\tau_{nt}\").next_to(t_nt, tangent_dir, buff=0.1)\n        s_xx_v = Arrow(p_origin + LEFT*offset, p_origin + LEFT*(txx+offset), buff=0, color=YELLOW)\n        s_xx_v.shift(UP * (p_top[1]/2))\n        l_xx = MathTex(r\"\\sigma_{xx}\").next_to(s_xx_v, LEFT)\n        s_yy_h = Arrow(p_origin + DOWN*offset, p_origin + DOWN*(tyy+offset), buff=0, color=YELLOW)\n        s_yy_h.shift(RIGHT * (side/2))\n        l_yy = MathTex(r\"\\sigma_{yy}\").next_to(s_yy_h, DOWN)\n        arc = Arc(radius=0.7, start_angle=PI, angle=theta, arc_center=p_right)\n        l_theta = MathTex(r\"\\theta\").next_to(arc, LEFT, buff=0.1).scale(0.8)\n        derivation = VGroup(\n            wedge, s_line, s_n, t_nt, l_sn, l_tnt,\n            s_xx_v, l_xx, s_yy_h, l_yy, arc, l_theta\n        )\n        derivation.move_to(ORIGIN)\n        self.add(derivation)",
    "DerivationScene": "class DerivationScene(Scene):\n    def construct(self):\n        element = Square(side_length=1, color=BLUE).set_fill(BLUE, opacity=0.5)\n        grid = VGroup()\n        for i in range(3):\n            for j in range(3):\n                square = element.copy().shift(RIGHT * i + UP * j)\n                grid.add(square)\n        grid.move_to(ORIGIN)\n        self.play(Create(element.scale(3)))\n        self.play(Create(grid))\n        grid.remove(element)\n        self.play(grid.animate.shift(LEFT * 1.5 + DOWN * 1.5))",
    "StressAnalysisScene": "class StressAnalysisScene(Scene):\n    def construct(self):\n        title = Text(\"Continuum Mechanics: Stress Analysis\", font_size=36)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(0.5)\n        element_size = 0.4\n        grid = VGroup()\n        l_shape_coords = []\n        for i in range(5):\n            for j in range(2):\n                l_shape_coords.append((i, j))\n        for i in range(1):\n            for j in range(2, 5):\n                l_shape_coords.append((i, j))\n        for i, j in l_shape_coords:\n            square = Square(side_length=element_size, color=BLUE, stroke_width=1)\n            square.set_fill(BLUE, opacity=0.3)\n            square.shift(RIGHT * j * element_size + UP * i * element_size)\n            grid.add(square)\n        grid.move_to(ORIGIN).shift(LEFT * 2)\n        structure_label = Text(\"General Structure\", font_size=24).next_to(grid, DOWN, buff=0.5)\n        self.play(\n            FadeOut(title, shift=UP),\n            Create(grid, lag_ratio=0.1),\n            Write(structure_label)\n        )\n        self.wait(1)\n        target_element = grid[12].copy()\n        highlight = target_element.copy().set_stroke(YELLOW, width=4)\n        self.play(Create(highlight))\n        self.wait(0.5)\n        zoom_label = Text(\"Single Element Analysis\", font_size=28)\n        zoom_label.to_edge(UP)\n        single_element = Square(side_length=2.5, color=BLUE, stroke_width=3)\n        single_element.set_fill(BLUE, opacity=0.2)\n        single_element.shift(RIGHT * 2.5)\n        self.play(\n            FadeOut(grid),\n            FadeOut(structure_label),\n            FadeOut(highlight),\n            Write(zoom_label)\n        )\n        self.play(Create(single_element))\n        self.wait(0.5)\n        dx_label = MathTex(r\"\\Delta x\", font_size=32).next_to(single_element, DOWN, buff=0.3)\n        dy_label = MathTex(r\"\\Delta y\", font_size=32).next_to(single_element, LEFT, buff=0.3)\n        self.play(Write(dx_label), Write(dy_label))\n        self.wait(0.5)\n        sigma_xx_left = Arrow(\n            single_element.get_left() + LEFT * 0.8,\n            single_element.get_left(),\n            color=RED, buff=0, stroke_width=6, max_tip_length_to_length_ratio=0.2\n        )\n        sigma_xx_right = Arrow(\n            single_element.get_right(),\n            single_element.get_right() + RIGHT * 0.8,\n            color=RED, buff=0, stroke_width=6, max_tip_length_to_length_ratio=0.2\n        )\n        sigma_xx_label = MathTex(r\"\\sigma_{xx}\", color=RED, font_size=28)\n        sigma_xx_label.next_to(sigma_xx_right, RIGHT, buff=0.2)\n        sigma_yy_bottom = Arrow(\n            single_element.get_bottom() + DOWN * 0.8,\n            single_element.get_bottom(),\n            color=GREEN, buff=0, stroke_width=6, max_tip_length_to_length_ratio=0.2\n        )\n        sigma_yy_top = Arrow(\n            single_element.get_top(),\n            single_element.get_top() + UP * 0.8,\n            color=GREEN, buff=0, stroke_width=6, max_tip_length_to_length_ratio=0.2\n        )\n        sigma_yy_label = MathTex(r\"\\sigma_{yy}\", color=GREEN, font_size=28)\n        sigma_yy_label.next_to(sigma_yy_top, UP, buff=0.2)\n        tau_xy_top = Arrow(\n            single_element.get_top() + LEFT * 0.6,\n            single_element.get_top() + LEFT * 0.6 + RIGHT * 0.7,\n            color=ORANGE, buff=0, stroke_width=5, max_tip_length_to_length_ratio=0.25\n        )\n        tau_xy_right = Arrow(\n            single_element.get_right() + DOWN * 0.6,\n            single_element.get_right() + DOWN * 0.6 + UP * 0.7,\n            color=ORANGE, buff=0, stroke_width=5, max_tip_length_to_length_ratio=0.25\n        )\n        tau_xy_label = MathTex(r\"\\tau_{xy}\", color=ORANGE, font_size=28)\n        tau_xy_label.next_to(tau_xy_right, RIGHT, buff=0.2)\n        stress_title = Text(\"Stress Components:\", font_size=24).to_corner(UL).shift(DOWN * 0.5)\n        self.play(Write(stress_title))\n        self.play(\n            Create(sigma_xx_left),\n            Create(sigma_xx_right),\n            Write(sigma_xx_label)\n        )\n        self.wait(0.5)\n        self.play(\n            Create(sigma_yy_bottom),\n            Create(sigma_yy_top),\n            Write(sigma_yy_label)\n        )\n        self.wait(0.5)\n        self.play(\n            Create(tau_xy_top),\n            Create(tau_xy_right),\n            Write(tau_xy_label)\n        )\n        self.wait(1)\n        stress_tensor = MathTex(\n            r\"\\sigma = \\begin{bmatrix} \\sigma_{xx} & \\tau_{xy} \\\\ \\tau_{xy} & \\sigma_{yy} \\end{bmatrix}\",\n            font_size=36\n        )\n        stress_tensor.to_corner(DL).shift(UP * 0.5 + RIGHT * 0.5)\n        self.play(Write(stress_tensor))\n        self.wait(2)\n        equilibrium = MathTex(\n            r\"\\frac{\\partial \\sigma_{xx}}{\\partial x} + \\frac{\\partial \\tau_{xy}}{\\partial y} = 0\",\n            font_size=32\n        )\n        equilibrium.next_to(stress_tensor, DOWN, buff=0.5)\n        self.play(Write(equilibrium))\n        self.wait(3)",
    "OvalCubesScene": "class OvalCubesScene(Scene):\n    def construct(self):\n        title = Text(\"Discretization of Curved Surface\", font_size=36)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(0.5)\n        oval = Ellipse(width=5, height=3.5, color=BLUE, stroke_width=4)\n        oval.set_fill(BLUE, opacity=0.3)\n        oval.move_to(ORIGIN).shift(LEFT * 2)\n        oval_label = Text(\"Continuous Oval Shape\", font_size=24)\n        oval_label.next_to(oval, DOWN, buff=0.5)\n        self.play(\n            FadeOut(title, shift=UP),\n            Create(oval),\n            Write(oval_label)\n        )\n        self.wait(1)\n        cube_size = 0.025\n        cubes = VGroup()\n        for x in np.arange(-2.5, 2.6, cube_size):\n            for y in np.arange(-1.75, 1.76, cube_size):\n                if (x**2 / 2.5**2) + (y**2 / 1.75**2) <= 1:\n                    cube = Square(side_length=cube_size, stroke_width=1)\n                    cube.set_fill(RED, opacity=0.6)\n                    cube.set_stroke(WHITE, width=0.5)\n                    cube.move_to(np.array([x - 2, y, 0]))\n                    cubes.add(cube)\n        self.play(\n            FadeOut(oval_label),\n            oval.animate.set_fill(opacity=0.1)\n        )\n        discretize_label = Text(\"Discretized with Small Elements\", font_size=24)\n        discretize_label.next_to(oval, DOWN, buff=0.5)\n        self.play(\n            Create(cubes, lag_ratio=0.01),\n            Write(discretize_label)\n        )\n        self.wait(1)\n        self.play(FadeOut(oval))\n        self.wait(1)\n        self.play(cubes.animate.space_out_submobjects(1.05))\n        self.wait(0.5)\n        self.play(cubes.animate.space_out_submobjects(1/1.05))\n        self.wait(1)\n        zoom_label = Text(\"Single Finite Element\", font_size=28)\n        zoom_label.to_edge(UP)\n        single_cube = Square(side_length=2, stroke_width=3, color=RED)\n        single_cube.set_fill(RED, opacity=0.6)\n        single_cube.shift(RIGHT * 3)\n        self.play(\n            cubes.animate.shift(LEFT * 1),\n            FadeOut(discretize_label),\n            Write(zoom_label)\n        )\n        self.play(Create(single_cube))\n        dx_label = MathTex(r\"\\Delta x\", font_size=28).next_to(single_cube, DOWN, buff=0.3)\n        dy_label = MathTex(r\"\\Delta y\", font_size=28).next_to(single_cube, LEFT, buff=0.3)\n        self.play(Write(dx_label), Write(dy_label))\n        self.wait(2)\n        final_text = Text(\n            \"Finite Element Method:\\nContinuous → Discrete\",\n            font_size=24,\n            line_spacing=1.2\n        ).to_corner(DR).shift(LEFT * 0.5 + UP * 0.5)\n        self.play(Write(final_text))\n        self.wait(3)",
    "RandomBezierCubesScene": "class RandomBezierCubesScene(Scene):\n    def construct(self):\n        title = Text(\"Discretization of Random Curved Shape\", font_size=36)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(0.5)\n        np.random.seed(42)\n        num_segments = 8\n        angles = np.linspace(0, 2*np.pi, num_segments + 1)[:-1]\n        control_points = []\n        for i, angle in enumerate(angles):\n            base_radius = 2.0\n            radius_variation = 0.5 + 0.8 * np.sin(3 * angle)\n            r = base_radius + radius_variation + np.random.uniform(-0.3, 0.3)\n            angle_offset = np.random.uniform(-0.2, 0.2)\n            actual_angle = angle + angle_offset\n            x = r * np.cos(actual_angle) - 2\n            y = r * np.sin(actual_angle)\n            control_points.append(np.array([x, y, 0]))\n        curved_shape = VMobject(color=BLUE, stroke_width=4)\n        curved_shape.set_points_smoothly(control_points + [control_points[0]])\n        curved_shape.set_fill(BLUE, opacity=0.3)\n        shape_label = Text(\"Random Curved Shape\", font_size=24)\n        shape_label.next_to(curved_shape, DOWN, buff=0.7)\n        self.play(\n            FadeOut(title, shift=UP),\n            Create(curved_shape),\n            Write(shape_label)\n        )\n        self.wait(1)\n        cube_size = 0.18\n        cubes = VGroup()\n        all_points = curved_shape.get_all_points()\n        x_min = np.min(all_points[:, 0]) - 0.5\n        x_max = np.max(all_points[:, 0]) + 0.5\n        y_min = np.min(all_points[:, 1]) - 0.5\n        y_max = np.max(all_points[:, 1]) + 0.5\n        for x in np.arange(x_min, x_max, cube_size):\n            for y in np.arange(y_min, y_max, cube_size):\n                cube_center = np.array([x, y, 0])\n                sample_points = [\n                    cube_center,\n                    cube_center + np.array([cube_size/3, cube_size/3, 0]),\n                    cube_center + np.array([-cube_size/3, cube_size/3, 0]),\n                    cube_center + np.array([cube_size/3, -cube_size/3, 0]),\n                    cube_center + np.array([-cube_size/3, -cube_size/3, 0]),\n                ]\n                if all(self.point_inside_bezier(pt, curved_shape) for pt in sample_points):\n                    cube = Square(side_length=cube_size, stroke_width=0.8)\n                    dist_from_center = np.linalg.norm([x + 2, y])\n                    hue = np.clip(dist_from_center / 3.0, 0, 1)\n                    cube.set_fill(interpolate_color(PURPLE, YELLOW, hue), opacity=0.75)\n                    cube.set_stroke(WHITE, width=0.5)\n                    cube.move_to(cube_center)\n                    cubes.add(cube)\n        self.play(\n            FadeOut(shape_label),\n            curved_shape.animate.set_fill(opacity=0.1).set_stroke(width=2)\n        )\n        discretize_label = Text(\"Discretized with Finite Elements\", font_size=24)\n        discretize_label.next_to(curved_shape, DOWN, buff=0.7)\n        self.play(\n            Create(cubes, lag_ratio=0.003),\n            Write(discretize_label)\n        )\n        self.wait(1)\n        self.play(FadeOut(curved_shape))\n        self.wait(0.5)\n        self.play(cubes.animate.space_out_submobjects(1.1))\n        self.wait(0.5)\n        self.play(cubes.animate.space_out_submobjects(1/1.1))\n        self.wait(1)\n        zoom_label = Text(\"Single Finite Element\", font_size=28)\n        zoom_label.to_edge(UP)\n        single_cube = Square(side_length=2.5, stroke_width=3, color=ORANGE)\n        single_cube.set_fill(ORANGE, opacity=0.75)\n        single_cube.shift(RIGHT * 3.5)\n        self.play(\n            cubes.animate.shift(LEFT * 1.5).scale(0.85),\n            FadeOut(discretize_label),\n            Write(zoom_label)\n        )\n        self.play(Create(single_cube))\n        dx_label = MathTex(r\"\\Delta x\", font_size=32).next_to(single_cube, DOWN, buff=0.3)\n        dy_label = MathTex(r\"\\Delta y\", font_size=32).next_to(single_cube, LEFT, buff=0.3)\n        self.play(Write(dx_label), Write(dy_label))\n        self.wait(1)\n        element_count = Text(\n            f\"Total Elements: {len(cubes)}\",\n            font_size=22,\n            color=YELLOW\n        ).to_corner(UL).shift(DOWN * 0.5)\n        self.play(Write(element_count))\n        self.wait(1)\n        final_text = Text(\n            \"FEM: Complex Geometry → Discrete Mesh\",\n            font_size=22,\n            line_spacing=1.2\n        ).to_corner(DR).shift(LEFT * 0.5 + UP * 0.5)\n        self.play(Write(final_text))\n        self.wait(3)\n    def point_inside_bezier(self, point, bezier_curve):\n        \"\"\"\n        Check if a point is inside a closed bezier curve using ray casting\n        \"\"\"\n        x, y = point[0], point[1]\n        curve_points = bezier_curve.get_all_points()\n        n = len(curve_points)\n        if n < 3:\n            return False\n        inside = False\n        p1x, p1y = curve_points[0][0], curve_points[0][1]\n        for i in range(1, n):\n            p2x, p2y = curve_points[i][0], curve_points[i][1]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xinters:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n        p2x, p2y = curve_points[0][0], curve_points[0][1]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n        return inside",
    "CircularBodyForcesScene": "class CircularBodyForcesScene(Scene):\n    def construct(self):\n        title = Text(\"Finite Element Analysis: Body Under Load\", font_size=36)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait(0.5)\n        np.random.seed(15)\n        num_points = 12\n        angles = np.linspace(0, 2*np.pi, num_points + 1)[:-1]\n        control_points = []\n        base_radius = 2.2\n        for angle in angles:\n            r = base_radius + np.random.uniform(-0.15, 0.15)\n            x = r * np.cos(angle)\n            y = r * np.sin(angle)\n            control_points.append(np.array([x, y, 0]))\n        circular_body = VMobject(color=BLUE, stroke_width=4)\n        circular_body.set_points_smoothly(control_points + [control_points[0]])\n        circular_body.set_fill(BLUE, opacity=0.3)\n        circular_body.shift(LEFT * 0.5)\n        body_label = Text(\"Circular Body\", font_size=24)\n        body_label.next_to(circular_body, DOWN, buff=0.5)\n        self.play(\n            FadeOut(title, shift=UP),\n            Create(circular_body),\n            Write(body_label)\n        )\n        self.wait(1)\n        forces = VGroup()\n        force_labels = VGroup()\n        f_top = Arrow(\n            circular_body.get_top() + UP * 1.2,\n            circular_body.get_top() + UP * 0.1,\n            color=RED, buff=0, stroke_width=8, max_tip_length_to_length_ratio=0.15\n        )\n        f_top_label = MathTex(\"F_1\", color=RED, font_size=28).next_to(f_top, UP, buff=0.1)\n        f_bottom = Arrow(\n            circular_body.get_bottom() + DOWN * 0.1,\n            circular_body.get_bottom() + DOWN * 1.2,\n            color=RED, buff=0, stroke_width=8, max_tip_length_to_length_ratio=0.15\n        )\n        f_bottom_label = MathTex(\"F_2\", color=RED, font_size=28).next_to(f_bottom, DOWN, buff=0.1)\n        f_left = Arrow(\n            circular_body.get_left() + LEFT * 1.0,\n            circular_body.get_left() + LEFT * 0.1,\n            color=GREEN, buff=0, stroke_width=7, max_tip_length_to_length_ratio=0.15\n        )\n        f_left_label = MathTex(\"F_3\", color=GREEN, font_size=28).next_to(f_left, LEFT, buff=0.1)\n        f_right = Arrow(\n            circular_body.get_right() + RIGHT * 0.1,\n            circular_body.get_right() + RIGHT * 1.0,\n            color=GREEN, buff=0, stroke_width=7, max_tip_length_to_length_ratio=0.15\n        )\n        f_right_label = MathTex(\"F_4\", color=GREEN, font_size=28).next_to(f_right, RIGHT, buff=0.1)\n        forces.add(f_top, f_bottom, f_left, f_right)\n        force_labels.add(f_top_label, f_bottom_label, f_left_label, f_right_label)\n        self.play(\n            FadeOut(body_label),\n            *[Create(f) for f in forces],\n            *[Write(label) for label in force_labels]\n        )\n        self.wait(1.5)\n        cube_size = 0.22\n        cubes = VGroup()\n        all_points = circular_body.get_all_points()\n        x_min = np.min(all_points[:, 0]) - 0.5\n        x_max = np.max(all_points[:, 0]) + 0.5\n        y_min = np.min(all_points[:, 1]) - 0.5\n        y_max = np.max(all_points[:, 1]) + 0.5\n        for x in np.arange(x_min, x_max, cube_size):\n            for y in np.arange(y_min, y_max, cube_size):\n                cube_center = np.array([x, y, 0])\n                sample_points = [\n                    cube_center,\n                    cube_center + np.array([cube_size/3, cube_size/3, 0]),\n                    cube_center + np.array([-cube_size/3, cube_size/3, 0]),\n                    cube_center + np.array([cube_size/3, -cube_size/3, 0]),\n                    cube_center + np.array([-cube_size/3, -cube_size/3, 0]),\n                ]\n                if all(self.point_inside_curve(pt, circular_body) for pt in sample_points):\n                    cube = Square(side_length=cube_size, stroke_width=0.8)\n                    cube.set_fill(BLUE, opacity=0.6)\n                    cube.set_stroke(WHITE, width=0.6)\n                    cube.move_to(cube_center)\n                    cubes.add(cube)\n        mesh_label = Text(\"Discretized Mesh\", font_size=24)\n        mesh_label.next_to(circular_body, DOWN, buff=0.5)\n        self.play(\n            circular_body.animate.set_fill(opacity=0.1).set_stroke(width=2),\n            Create(cubes, lag_ratio=0.003),\n            Write(mesh_label)\n        )\n        self.wait(1.5)\n        target_index = len(cubes) // 2 + 15\n        target_element = cubes[target_index]\n        highlight = target_element.copy().set_stroke(YELLOW, width=5).set_fill(YELLOW, opacity=0.3)\n        self.play(Create(highlight))\n        self.wait(0.5)\n        extraction_label = Text(\"Element Extraction\", font_size=28)\n        extraction_label.to_edge(UP)\n        extracted_element = target_element.copy()\n        self.play(\n            FadeOut(circular_body),\n            FadeOut(forces),\n            FadeOut(force_labels),\n            FadeOut(mesh_label),\n            Write(extraction_label)\n        )\n        other_cubes = VGroup(*[c for i, c in enumerate(cubes) if i != target_index])\n        self.play(\n            other_cubes.animate.set_opacity(0.15),\n            highlight.animate.scale(2).shift(RIGHT * 2.5),\n            run_time=1.5\n        )\n        self.play(FadeOut(highlight))\n        single_element = Square(side_length=3, stroke_width=4, color=ORANGE)\n        single_element.set_fill(ORANGE, opacity=0.5)\n        single_element.shift(RIGHT * 2.5)\n        self.play(\n            other_cubes.animate.shift(LEFT * 2).scale(0.7),\n            Create(single_element)\n        )\n        self.wait(1)\n        stress_label = Text(\"Stress Analysis on Element\", font_size=24)\n        stress_label.next_to(single_element, UP, buff=0.5)\n        self.play(Write(stress_label))\n        sigma_x = Arrow(\n            single_element.get_right(),\n            single_element.get_right() + RIGHT * 0.9,\n            color=RED, buff=0, stroke_width=6, max_tip_length_to_length_ratio=0.2\n        )\n        sigma_x_label = MathTex(r\"\\sigma_{xx}\", color=RED, font_size=26).next_to(sigma_x, RIGHT)\n        sigma_y = Arrow(\n            single_element.get_top(),\n            single_element.get_top() + UP * 0.9,\n            color=GREEN, buff=0, stroke_width=6, max_tip_length_to_length_ratio=0.2\n        )\n        sigma_y_label = MathTex(r\"\\sigma_{yy}\", color=GREEN, font_size=26).next_to(sigma_y, UP)\n        tau = Arrow(\n            single_element.get_top() + LEFT * 0.8,\n            single_element.get_top() + LEFT * 0.8 + RIGHT * 0.8,\n            color=PURPLE, buff=0, stroke_width=5, max_tip_length_to_length_ratio=0.25\n        )\n        tau_label = MathTex(r\"\\tau_{xy}\", color=PURPLE, font_size=26).next_to(tau, UP, buff=0.1)\n        self.play(\n            Create(sigma_x), Write(sigma_x_label),\n        )\n        self.wait(0.3)\n        self.play(\n            Create(sigma_y), Write(sigma_y_label),\n        )\n        self.wait(0.3)\n        self.play(\n            Create(tau), Write(tau_label),\n        )\n        self.wait(1)\n        dx = MathTex(r\"\\Delta x\", font_size=28).next_to(single_element, DOWN, buff=0.3)\n        dy = MathTex(r\"\\Delta y\", font_size=28).next_to(single_element, LEFT, buff=0.3)\n        self.play(Write(dx), Write(dy))\n        self.wait(2)\n        self.play(\n            single_element.animate.set_fill(opacity=0.7),\n            rate_func=there_and_back,\n            run_time=1\n        )\n        self.wait(2)\n    def point_inside_curve(self, point, curve):\n        \"\"\"Ray casting algorithm for point in polygon\"\"\"\n        x, y = point[0], point[1]\n        curve_points = curve.get_all_points()\n        n = len(curve_points)\n        if n < 3:\n            return False\n        inside = False\n        p1x, p1y = curve_points[0][0], curve_points[0][1]\n        for i in range(1, n):\n            p2x, p2y = curve_points[i][0], curve_points[i][1]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xinters:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n        p2x, p2y = curve_points[0][0], curve_points[0][1]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n        return inside"
}