{
    "StressTransformation2D": "class StressTransformation2D(Scene):\n    def construct(self):\n        sigma_x = 10\n        sigma_y = 2\n        tau_xy = 4\n        theta_final = PI / 6\n        title = Text(\"2D Stress Transformation\", font_size=32).to_edge(UP, buff=0.3)\n        self.play(Write(title))\n        self.wait(0.5)\n        side = 2\n        element_center = LEFT * 4\n        element = Square(side_length=side, color=YELLOW, fill_opacity=0.3)\n        element.move_to(element_center)\n        self.play(Create(element))\n        arrow_len = 1.0\n        sigma_x_right = Arrow(\n            start=element.get_right(),\n            end=element.get_right() + RIGHT * arrow_len,\n            color=RED, buff=0\n        )\n        sigma_x_left = Arrow(\n            start=element.get_left(),\n            end=element.get_left() + LEFT * arrow_len,\n            color=RED, buff=0\n        )\n        sigma_x_label = MathTex(r\"\\sigma_x\", color=RED, font_size=28).next_to(sigma_x_right, RIGHT, buff=0.1)\n        sigma_y_top = Arrow(\n            start=element.get_top(),\n            end=element.get_top() + UP * arrow_len,\n            color=BLUE, buff=0\n        )\n        sigma_y_bottom = Arrow(\n            start=element.get_bottom(),\n            end=element.get_bottom() + DOWN * arrow_len,\n            color=BLUE, buff=0\n        )\n        sigma_y_label = MathTex(r\"\\sigma_y\", color=BLUE, font_size=28).next_to(sigma_y_top, UP, buff=0.1)\n        tau_right_start = element.get_right() + DOWN * 0.4\n        tau_right_end = element.get_right() + UP * 0.4\n        tau_xy_right = Arrow(\n            start=tau_right_start,\n            end=tau_right_end,\n            color=ORANGE, buff=0\n        )\n        tau_top_start = element.get_top() + LEFT * 0.4\n        tau_top_end = element.get_top() + RIGHT * 0.4\n        tau_xy_top = Arrow(\n            start=tau_top_start,\n            end=tau_top_end,\n            color=ORANGE, buff=0\n        )\n        tau_xy_label = MathTex(r\"\\tau_{xy}\", color=ORANGE, font_size=28).next_to(tau_xy_right, RIGHT, buff=0.15)\n        self.play(\n            Create(sigma_x_right), Create(sigma_x_left),\n            Create(sigma_y_top), Create(sigma_y_bottom),\n        )\n        self.play(\n            Create(tau_xy_right), Create(tau_xy_top),\n        )\n        self.play(\n            Write(sigma_x_label), Write(sigma_y_label), Write(tau_xy_label)\n        )\n        self.wait(0.5)\n        stress_values = VGroup(\n            MathTex(r\"\\sigma_x = \" + str(sigma_x), color=RED, font_size=24),\n            MathTex(r\"\\sigma_y = \" + str(sigma_y), color=BLUE, font_size=24),\n            MathTex(r\"\\tau_{xy} = \" + str(tau_xy), color=ORANGE, font_size=24)\n        ).arrange(DOWN, aligned_edge=LEFT, buff=0.15).to_corner(DL, buff=0.5)\n        self.play(Write(stress_values))\n        self.wait(0.5)\n        eq_title = Text(\"Transformation Equations:\", font_size=18, color=WHITE).to_edge(RIGHT, buff=0.3).shift(UP * 2.5)\n        eq1 = MathTex(\n            r\"\\sigma_{x'} = \\frac{\\sigma_x + \\sigma_y}{2} + \\frac{\\sigma_x - \\sigma_y}{2}\\cos 2\\theta\",\n            font_size=18\n        ).next_to(eq_title, DOWN, buff=0.2, aligned_edge=LEFT)\n        eq1b = MathTex(\n            r\"+ \\tau_{xy}\\sin 2\\theta\",\n            font_size=18\n        ).next_to(eq1, DOWN, buff=0.1, aligned_edge=LEFT).shift(RIGHT * 0.5)\n        eq2 = MathTex(\n            r\"\\sigma_{y'} = \\frac{\\sigma_x + \\sigma_y}{2} - \\frac{\\sigma_x - \\sigma_y}{2}\\cos 2\\theta\",\n            font_size=18\n        ).next_to(eq1b, DOWN, buff=0.2, aligned_edge=LEFT).shift(LEFT * 0.5)\n        eq2b = MathTex(\n            r\"- \\tau_{xy}\\sin 2\\theta\",\n            font_size=18\n        ).next_to(eq2, DOWN, buff=0.1, aligned_edge=LEFT).shift(RIGHT * 0.5)\n        eq3 = MathTex(\n            r\"\\tau_{x'y'} = -\\frac{\\sigma_x - \\sigma_y}{2}\\sin 2\\theta + \\tau_{xy}\\cos 2\\theta\",\n            font_size=18\n        ).next_to(eq2b, DOWN, buff=0.2, aligned_edge=LEFT).shift(LEFT * 0.5)\n        equations = VGroup(eq_title, eq1, eq1b, eq2, eq2b, eq3)\n        equations.scale(0.9).to_edge(RIGHT, buff=0.2).shift(UP * 0.5)\n        self.play(Write(eq_title))\n        self.play(Write(eq1), Write(eq1b))\n        self.play(Write(eq2), Write(eq2b))\n        self.play(Write(eq3))\n        self.wait(1)\n        theta = theta_final\n        sigma_x_prime = (sigma_x + sigma_y) / 2 + (sigma_x - sigma_y) / 2 * np.cos(2 * theta) + tau_xy * np.sin(2 * theta)\n        sigma_y_prime = (sigma_x + sigma_y) / 2 - (sigma_x - sigma_y) / 2 * np.cos(2 * theta) - tau_xy * np.sin(2 * theta)\n        tau_xy_prime = -(sigma_x - sigma_y) / 2 * np.sin(2 * theta) + tau_xy * np.cos(2 * theta)\n        R = np.array([\n            [np.cos(theta), -np.sin(theta), 0],\n            [np.sin(theta), np.cos(theta), 0],\n            [0, 0, 1]\n        ])\n        element_rotated = Square(side_length=side, color=GREEN, fill_opacity=0.3)\n        element_rotated.rotate(theta)\n        element_rotated.move_to(element_center)\n        dir_x = R @ np.array([1, 0, 0])\n        dir_y = R @ np.array([0, 1, 0])\n        center = element_rotated.get_center()\n        sigma_xp_right = Arrow(\n            start=center + dir_x * side / 2,\n            end=center + dir_x * (side / 2 + arrow_len),\n            color=RED, buff=0\n        )\n        sigma_xp_left = Arrow(\n            start=center - dir_x * side / 2,\n            end=center - dir_x * (side / 2 + arrow_len),\n            color=RED, buff=0\n        )\n        sigma_xp_label = MathTex(r\"\\sigma_{x'}\", color=RED, font_size=28).next_to(sigma_xp_right.get_end(), RIGHT, buff=0.1)\n        sigma_yp_top = Arrow(\n            start=center + dir_y * side / 2,\n            end=center + dir_y * (side / 2 + arrow_len),\n            color=BLUE, buff=0\n        )\n        sigma_yp_bottom = Arrow(\n            start=center - dir_y * side / 2,\n            end=center - dir_y * (side / 2 + arrow_len),\n            color=BLUE, buff=0\n        )\n        sigma_yp_label = MathTex(r\"\\sigma_{y'}\", color=BLUE, font_size=28).next_to(sigma_yp_top.get_end(), UP, buff=0.1)\n        tau_xyp_right = Arrow(\n            start=center + dir_x * side / 2 - dir_y * 0.4,\n            end=center + dir_x * side / 2 + dir_y * 0.4,\n            color=ORANGE, buff=0\n        )\n        tau_xyp_top = Arrow(\n            start=center + dir_y * side / 2 - dir_x * 0.4,\n            end=center + dir_y * side / 2 + dir_x * 0.4,\n            color=ORANGE, buff=0\n        )\n        tau_xyp_label = MathTex(r\"\\tau_{x'y'}\", color=ORANGE, font_size=28).next_to(tau_xyp_right.get_end(), RIGHT, buff=0.15)\n        angle_arc = Arc(radius=0.6, start_angle=0, angle=theta, color=WHITE).move_to(element_center, aligned_edge=ORIGIN)\n        theta_label_arc = MathTex(r\"\\theta\", font_size=24).next_to(angle_arc, UR, buff=0.05)\n        self.play(\n            ReplacementTransform(element, element_rotated),\n            ReplacementTransform(sigma_x_right, sigma_xp_right),\n            ReplacementTransform(sigma_x_left, sigma_xp_left),\n            ReplacementTransform(sigma_y_top, sigma_yp_top),\n            ReplacementTransform(sigma_y_bottom, sigma_yp_bottom),\n            ReplacementTransform(tau_xy_right, tau_xyp_right),\n            ReplacementTransform(tau_xy_top, tau_xyp_top),\n            ReplacementTransform(sigma_x_label, sigma_xp_label),\n            ReplacementTransform(sigma_y_label, sigma_yp_label),\n            ReplacementTransform(tau_xy_label, tau_xyp_label),\n            Create(angle_arc),\n            Write(theta_label_arc),\n            run_time=2\n        )\n        self.wait(1)\n        transformed_values = VGroup(\n            MathTex(r\"\\sigma_{x'} = \" + f\"{sigma_x_prime:.2f}\", color=RED, font_size=24),\n            MathTex(r\"\\sigma_{y'} = \" + f\"{sigma_y_prime:.2f}\", color=BLUE, font_size=24),\n            MathTex(r\"\\tau_{x'y'} = \" + f\"{tau_xy_prime:.2f}\", color=ORANGE, font_size=24),\n            MathTex(r\"\\theta = 30Â°\", color=WHITE, font_size=24)\n        ).arrange(DOWN, aligned_edge=LEFT, buff=0.15).to_corner(DL, buff=0.5)\n        self.play(ReplacementTransform(stress_values, transformed_values))\n        self.wait(2)"
}