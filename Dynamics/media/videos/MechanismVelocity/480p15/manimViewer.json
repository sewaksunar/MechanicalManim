{
    "MechanismI": "class MechanismI(Scene):\n    def construct(self):\n        axis = Axes(\n            x_range=[-.4, .8, 1],\n            y_range=[-0.4, .8, 1],\n            x_length=10,\n            y_length=5,\n            tips=False,\n        )\n        axis.move_to(ORIGIN+DOWN)\n        labels = axis.get_axis_labels(\n            MathTex(r\"x\").scale(0.7),\n            MathTex(r\"y\").scale(0.7)\n        )\n        pO2 = axis.get_origin()\n        O2 = Dot(pO2, color=YELLOW)\n        labelsO2 = MathTex(r\"O_2\").scale(0.7)\n        labelsO2.move_to(pO2 + LEFT * 0.3 + DOWN * 0.3)\n        scale = 1.5\n        O4O2 = 250/100 * scale\n        labelsO4 = MathTex(r\"O_4\").scale(0.7)\n        pO4 = pO2 + RIGHT * O4O2\n        O4 = Dot(pO2 + RIGHT * O4O2, color=YELLOW)\n        labelsO4.move_to(pO2 + RIGHT * O4O2 + LEFT * 0.3 + DOWN * 0.3)\n        O2A = 100/100 * scale\n        O2A_angle = 120 * DEGREES\n        pA = pO2 + O2A * np.array([np.cos(O2A_angle), np.sin(O2A_angle), 0])\n        A = Dot(pA, color=BLUE)\n        labelsA = MathTex(r\"A\").scale(0.7)\n        labelsA.move_to(pA + UP * 0.3 + LEFT * 0.3)\n        link2 = VGroup(\n            Line(pO2, pA, color=BLUE),\n            A,\n            labelsA\n        )\n        BA = 250/100 * scale\n        BO4 = 300/100 * scale\n        B_x, B_y = sp.symbols('B_x B_y', real=True)\n        eq1 = (B_x - pO4[0])**2 + (B_y - pO4[1])**2 - BO4**2\n        eq2 = (B_x - pA[0])**2 + (B_y - pA[1])**2 - BA**2\n        solutions = sp.solve([eq1, eq2], (B_x, B_y))\n        if len(solutions) == 0:\n            print(\"Warning: No valid configuration found\")\n            pB = pA + RIGHT * BA\n        elif len(solutions) == 1:\n            pB = np.array([float(solutions[0][0]), float(solutions[0][1]), 0])\n        else:\n            sol1 = np.array([float(solutions[0][0]), float(solutions[0][1]), 0])\n            sol2 = np.array([float(solutions[1][0]), float(solutions[1][1]), 0])\n            if sol1[1] >= sol2[1]:\n                pB = sol1\n            else:\n                pB = sol2\n            \"\"\"\n            v1 = pA - pO2\n            v2_1 = sol1 - pA\n            v2_2 = sol2 - pA\n            cross1 = v1[0] * v2_1[1] - v1[1] * v2_1[0]\n            cross2 = v1[0] * v2_2[1] - v1[1] * v2_2[0]\n            if cross1 > cross2:\n                pB = sol1\n            else:\n                pB = sol2\n            \"\"\"\n        link3 = VGroup(\n            Line(pA, pB, color=GREEN),\n            Dot(pB, color=GREEN),\n            MathTex(r\"B\").scale(0.7).move_to(pB + UP * 0.3 + RIGHT * 0.3)\n        )\n        link4 = VGroup(\n            Line(pB, pO4, color=RED),\n        )\n        if abs(O2A_angle) < 0.01 or abs(O2A_angle - PI) < 0.01:\n            arc = Arc(\n                radius=0.5,\n                start_angle=0,\n                angle=O2A_angle if abs(O2A_angle) > 0.01 else 0.1,\n                arc_center=pO2\n            )\n        else:\n            arc = Angle(Line(pO2, pO4), Line(pO2, pA), radius=0.5, other_angle=False)\n        angle_deg = O2A_angle * 180 / PI\n        value = MathTex(f\"{angle_deg:.1f}^{{\\\\circ}}\").scale(0.7)\n        value.next_to(arc.get_end() + UP*0.2 + RIGHT*0.1)\n        self.add(axis, labels, labelsO2, O2, labelsO4, O4, link2, link3, link4, arc, value)",
    "MechanismAnimation": "class MechanismAnimation(Scene):\n    def construct(self):\n        \"\"\"Animated version showing the mechanism in motion with velocity analysis\"\"\"\n        axis = Axes(\n            x_range=[-.4, .8, 1],\n            y_range=[-0.4, .8, 1],\n            x_length=10,\n            y_length=5,\n            tips=False,\n        )\n        axis.move_to(ORIGIN+DOWN)\n        labels = axis.get_axis_labels(\n            MathTex(r\"x\").scale(0.7),\n            MathTex(r\"y\").scale(0.7)\n        )\n        pO2 = axis.get_origin()\n        scale = 1.5\n        O4O2 = 250/100 * scale\n        pO4 = pO2 + RIGHT * O4O2\n        O2 = Dot(pO2, color=YELLOW)\n        O4 = Dot(pO4, color=YELLOW)\n        labelsO2 = MathTex(r\"O_2\").scale(0.7).move_to(pO2 + LEFT * 0.3 + DOWN * 0.3)\n        labelsO4 = MathTex(r\"O_4\").scale(0.7).move_to(pO4 + LEFT * 0.3 + DOWN * 0.3)\n        self.add(axis, labels, O2, O4, labelsO2, labelsO4)\n        O2A = 100/100 * scale\n        BA = 250/100 * scale\n        BO4 = 300/100 * scale\n        omega2 = 45 * DEGREES\n        angles = np.linspace(120*DEGREES, (120+360)*DEGREES, 120)\n        positions_A = []\n        positions_B = []\n        velocities_A = []\n        velocities_B = []\n        omega3_values = []\n        omega4_values = []\n        for i, angle in enumerate(angles):\n            pA = pO2 + O2A * np.array([np.cos(angle), np.sin(angle), 0])\n            B_x, B_y = sp.symbols('B_x B_y', real=True)\n            eq1 = (B_x - pO4[0])**2 + (B_y - pO4[1])**2 - BO4**2\n            eq2 = (B_x - pA[0])**2 + (B_y - pA[1])**2 - BA**2\n            solutions = sp.solve([eq1, eq2], (B_x, B_y))\n            if len(solutions) >= 1:\n                sol1 = np.array([float(solutions[0][0]), float(solutions[0][1]), 0])\n                if len(solutions) == 2:\n                    sol2 = np.array([float(solutions[1][0]), float(solutions[1][1]), 0])\n                    pB = sol1 if sol1[1] >= sol2[1] else sol2\n                else:\n                    pB = sol1\n            else:\n                pB = pA + RIGHT * BA\n            positions_A.append(pA)\n            positions_B.append(pB)\n            r_A = pA - pO2\n            v_A = omega2 * np.array([-r_A[1], r_A[0], 0])\n            velocities_A.append(v_A)\n            r_BA = pB - pA\n            r_BO4 = pB - pO4\n            if np.linalg.norm(r_BA[:2]) > 0.01 and np.linalg.norm(r_BO4[:2]) > 0.01:\n                r_BA_perp = np.array([-r_BA[1], r_BA[0]])\n                r_BO4_perp = np.array([-r_BO4[1], r_BO4[0]])\n                A_mat = np.column_stack([r_BA_perp, -r_BO4_perp])\n                if np.abs(np.linalg.det(A_mat)) > 0.01:\n                    omega_vals = np.linalg.solve(A_mat, -v_A[:2])\n                    omega3 = omega_vals[0]\n                    omega4 = omega_vals[1]\n                else:\n                    omega3 = 0\n                    omega4 = 0\n            else:\n                omega3 = 0\n                omega4 = 0\n            omega3_values.append(omega3)\n            omega4_values.append(omega4)\n            v_B_from_A = v_A + omega3 * np.array([-r_BA[1], r_BA[0], 0])\n            velocities_B.append(v_B_from_A)\n        angle_tracker = ValueTracker(120*DEGREES)\n        def get_index():\n            angle_val = angle_tracker.get_value()\n            idx = int(((angle_val - 120*DEGREES) / (360*DEGREES)) * (len(angles) - 1))\n            return min(max(idx, 0), len(angles) - 1)\n        def get_mechanism_data():\n            idx = get_index()\n            return (positions_A[idx], positions_B[idx],\n                    velocities_A[idx], velocities_B[idx],\n                    omega3_values[idx], omega4_values[idx])\n        path_A = TracedPath(\n            lambda: get_mechanism_data()[0],\n            stroke_color=BLUE,\n            stroke_width=2,\n            stroke_opacity=0.6\n        )\n        path_B = TracedPath(\n            lambda: get_mechanism_data()[1],\n            stroke_color=GREEN,\n            stroke_width=2,\n            stroke_opacity=0.6\n        )\n        link2 = always_redraw(lambda: Line(\n            pO2,\n            get_mechanism_data()[0],\n            color=BLUE,\n            stroke_width=4\n        ))\n        pointA = always_redraw(lambda: Dot(\n            get_mechanism_data()[0],\n            color=BLUE,\n            radius=0.08\n        ))\n        labelA = always_redraw(lambda: MathTex(r\"A\").scale(0.7).next_to(\n            get_mechanism_data()[0],\n            UP * 0.5 + LEFT * 0.3\n        ))\n        link3 = always_redraw(lambda: Line(\n            get_mechanism_data()[0],\n            get_mechanism_data()[1],\n            color=GREEN,\n            stroke_width=4\n        ))\n        pointB = always_redraw(lambda: Dot(\n            get_mechanism_data()[1],\n            color=GREEN,\n            radius=0.08\n        ))\n        labelB = always_redraw(lambda: MathTex(r\"B\").scale(0.7).next_to(\n            get_mechanism_data()[1],\n            UP * 0.5 + RIGHT * 0.3\n        ))\n        link4 = always_redraw(lambda: Line(\n            get_mechanism_data()[1],\n            pO4,\n            color=RED,\n            stroke_width=4\n        ))\n        arc = always_redraw(lambda: Arc(\n            radius=0.5,\n            start_angle=0*DEGREES,\n            angle=angle_tracker.get_value(),\n            arc_center=pO2,\n            color=YELLOW\n        ))\n        angle_value = always_redraw(lambda: DecimalNumber(\n            angle_tracker.get_value() * 180 / PI,\n            num_decimal_places=1,\n            unit=r\"^{\\circ}\"\n        ).scale(0.6).next_to(arc.get_end() + UP * 0.15 + RIGHT * 0.15))\n        def get_velocity_arrow_A():\n            pA, pB, vA, vB, omega3, omega4 = get_mechanism_data()\n            v_mag = np.linalg.norm(vA)\n            if v_mag > 0.01:\n                v_dir = vA / v_mag\n                arrow = Arrow(\n                    pA,\n                    pA + v_dir * v_mag * 0.5,\n                    color=BLUE,\n                    buff=0,\n                    stroke_width=4,\n                    max_tip_length_to_length_ratio=0.2\n                )\n                return arrow\n            return VGroup()\n        velocity_arrow_A = always_redraw(get_velocity_arrow_A)\n        def get_velocity_arrow_B():\n            pA, pB, vA, vB, omega3, omega4 = get_mechanism_data()\n            v_mag = np.linalg.norm(vB)\n            if v_mag > 0.01:\n                v_dir = vB / v_mag\n                arrow = Arrow(\n                    pB,\n                    pB + v_dir * v_mag * 0.5,\n                    color=GREEN,\n                    buff=0,\n                    stroke_width=4,\n                    max_tip_length_to_length_ratio=0.2\n                )\n                return arrow\n            return VGroup()\n        velocity_arrow_B = always_redraw(get_velocity_arrow_B)\n        v_A_label = always_redraw(lambda: DecimalNumber(\n            np.linalg.norm(get_mechanism_data()[2]),\n            num_decimal_places=2,\n        ).scale(0.5).next_to(get_mechanism_data()[0] + get_mechanism_data()[2] * 0.5 * 0.5, UP * 0.3).set_color(BLUE))\n        v_B_label = always_redraw(lambda: DecimalNumber(\n            np.linalg.norm(get_mechanism_data()[3]),\n            num_decimal_places=2,\n        ).scale(0.5).next_to(get_mechanism_data()[1] + get_mechanism_data()[3] * 0.5 * 0.5, DOWN * 0.3).set_color(GREEN))\n        self.add(path_A, path_B)\n        self.add(link2, pointA, labelA, link3, pointB, labelB, link4)\n        self.add(arc, angle_value)\n        self.add(velocity_arrow_A, velocity_arrow_B)\n        self.add(v_A_label, v_B_label)\n        self.play(angle_tracker.animate.set_value((120+360)*DEGREES), run_time=10, rate_func=linear)\n        self.wait()"
}