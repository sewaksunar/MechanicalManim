{
    "pythagorean_theorem": "class pythagorean_theorem(Scene):\n    def cad_dimension(self, start, end, label_text, offset_val=0.5, scale=0.7,\n                            arrow_size=0.15, ext_line_extension=0.1):\n        \"\"\"Creates a CAD-style dimension with extension lines, arrows, and text.\"\"\"\n        p1 = Point(float(start[0]), float(start[1]))\n        p2 = Point(float(end[0]), float(end[1]))\n        main_seg = Segment(p1, p2)\n        dist = float(main_seg.length)\n        if dist == 0:\n            return VGroup()\n        midpoint_sp = main_seg.midpoint\n        main_line = SpLine(p1, p2)\n        perp_line = main_line.perpendicular_line(midpoint_sp)\n        perp_dir = perp_line.direction.unit\n        perp_dir_np = np.array([float(perp_dir.x), float(perp_dir.y), 0])\n        if offset_val < 0:\n            perp_dir_np = -perp_dir_np\n        offset_distance = abs(offset_val)\n        dim_start = start + perp_dir_np * offset_distance\n        dim_end = end + perp_dir_np * offset_distance\n        direction = end - start\n        unit_dir = direction / np.linalg.norm(direction)\n        ext_line_1 = Line(\n            start - perp_dir_np * 0.1,\n            dim_start + perp_dir_np * ext_line_extension,\n            color=GRAY,\n            stroke_width=1\n        )\n        ext_line_2 = Line(\n            end - perp_dir_np * 0.1,\n            dim_end + perp_dir_np * ext_line_extension,\n            color=GRAY,\n            stroke_width=1\n        )\n        dim_line = Line(dim_start, dim_end, color=GRAY, stroke_width=2)\n        arrow_1 = Arrow(\n            dim_start + unit_dir * arrow_size,\n            dim_start,\n            buff=0,\n            color=GRAY,\n            stroke_width=2,\n            max_tip_length_to_length_ratio=1,\n            tip_length=arrow_size\n        )\n        arrow_2 = Arrow(\n            dim_end - unit_dir * arrow_size,\n            dim_end,\n            buff=0,\n            color=GRAY,\n            stroke_width=2,\n            max_tip_length_to_length_ratio=1,\n            tip_length=arrow_size\n        )\n        label = MathTex(label_text).scale(scale)\n        angle = float(sp.atan2(p2.y - p1.y, p2.x - p1.x))\n        if PI/2 < angle <= PI or -PI <= angle < -PI/2:\n            angle += PI\n        label.rotate(angle)\n        midpoint = (dim_start + dim_end) / 2\n        label.move_to(midpoint + perp_dir_np * 0.3)\n        return VGroup(ext_line_1, ext_line_2, dim_line, arrow_1, arrow_2, label)\n    def construct(self):\n        a, b = 3, 4\n        C_np = np.array([0, 0, 0])\n        A_np = np.array([b, 0, 0])\n        B_np = np.array([0, a, 0])\n        triangle_shape = Polygon(\n            C_np,\n            A_np,\n            B_np,\n            color=BLUE\n        )\n        labelC = MathTex(\"C\")\n        labelC.next_to(C_np, DOWN+LEFT)\n        labelA = MathTex(\"A\")\n        labelA.next_to(A_np, DOWN+RIGHT)\n        labelB = MathTex(\"B\")\n        labelB.next_to(B_np, UP+LEFT)\n        dotA = Dot(A_np)\n        dotB = Dot(B_np)\n        dotC = Dot(C_np)\n        triangle = VGroup(triangle_shape, dotA, labelA, dotB, labelB, dotC, labelC)\n        title = Title(f\"Pythagoras Theorem\")\n        self.add(title)\n        self.add(triangle.move_to(ORIGIN))\n        self.play(Create(triangle), run_time=3)\n        vertices = triangle_shape.get_vertices()\n        C_actual = vertices[0]\n        A_actual = vertices[1]\n        B_actual = vertices[2]\n        c_dim = self.cad_dimension(A_actual, B_actual, \"c\", offset_val=-0.3)\n        a_dim = self.cad_dimension(C_actual, B_actual, \"a\", offset_val=-0.3)\n        b_dim = self.cad_dimension(C_actual, A_actual, \"b\", offset_val=-0.3)\n        full_diagram = VGroup(triangle, c_dim, a_dim, b_dim)\n        self.play(Create(c_dim), run_time=1)\n        self.play(Create(a_dim), run_time=1)\n        self.play(Create(b_dim), run_time=1)\n        self.play(full_diagram.animate.move_to(LEFT*3), run_time=1)\n        anno_c = MathTex(\n            r\"c \\ \\text{is the hypotenous}\"\n        )\n        anno_a = MathTex(\n            r\"a \\ \\text{is the perpendicular}\"\n        )\n        anno_b = MathTex(\n            r\"b \\ \\text{is the base}\"\n        )\n        self.play(AnimationGroup(Indicate(c_dim, scale_factor=1),Indicate(labelC), Write(anno_c.move_to(RIGHT*3))))\n        self.play(AnimationGroup(Indicate(a_dim, scale_factor=1),Indicate(labelA), Write(anno_a.next_to(RIGHT*3, DOWN))))\n        self.play(AnimationGroup(Indicate(b_dim, scale_factor=1),Indicate(labelB), Write(anno_b.next_to(RIGHT*3, DOWN*3))))\n        anno = VGroup(anno_a, anno_b, anno_c)\n        self.play(FadeOut(anno))\n        equ = MathTex(r\"c^2 = a^2 + b^2\")\n        self.play(Write(equ.move_to(RIGHT*3)))\n        self.wait(2)",
    "InscribedAngleTheoremI": "class InscribedAngleTheoremI(Scene):\n    def construct(self):\n        radius_tracker = ValueTracker(2)\n        angle1_tracker = ValueTracker(60)\n        angle2_tracker = ValueTracker(120)\n        angle3_tracker = ValueTracker(230)\n        angle4_tracker = ValueTracker(330)\n        c = always_redraw(lambda: Circle(\n            radius=radius_tracker.get_value(),\n            color=WHITE\n        ).move_to(ORIGIN))\n        dot_p1 = always_redraw(lambda: Dot(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n            color=YELLOW\n        ))\n        dot_p2 = always_redraw(lambda: Dot(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n            color=YELLOW\n        ))\n        dot_p3 = always_redraw(lambda: Dot(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle3_tracker.get_value()*DEGREES),\n            color=YELLOW\n        ))\n        dot_p4 = always_redraw(lambda: Dot(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle4_tracker.get_value()*DEGREES),\n            color=YELLOW\n        ))\n        line1 = always_redraw(lambda: Line(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle3_tracker.get_value()*DEGREES),\n            color=BLUE\n        ))\n        line2 = always_redraw(lambda: Line(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle4_tracker.get_value()*DEGREES),\n            color=BLUE\n        ))\n        line3 = always_redraw(lambda: Line(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle3_tracker.get_value()*DEGREES),\n            color=RED\n        ))\n        line4 = always_redraw(lambda: Line(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle4_tracker.get_value()*DEGREES),\n            color=RED\n        ))\n        arc = always_redraw(lambda: Arc(\n            radius=radius_tracker.get_value(),\n            start_angle=angle3_tracker.get_value()*DEGREES,\n            angle=(angle4_tracker.get_value() - angle3_tracker.get_value())*DEGREES,\n            color=GREEN,\n            stroke_width=6\n        ))\n        angle1 = always_redraw(lambda: Angle(\n            Line(\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle3_tracker.get_value()*DEGREES)\n            ),\n            Line(\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle4_tracker.get_value()*DEGREES)\n            ),\n            radius=0.5,\n            color=YELLOW\n        ))\n        angle2 = always_redraw(lambda: Angle(\n            Line(\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle3_tracker.get_value()*DEGREES)\n            ),\n            Line(\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle4_tracker.get_value()*DEGREES)\n            ),\n            radius=0.5,\n            color=YELLOW\n        ))\n        label1 = always_redraw(lambda: MathTex(r\"\\theta_1\", color=BLUE).scale(0.7).next_to(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n            DOWN+LEFT, buff=0.5\n        ))\n        label2 = always_redraw(lambda: MathTex(r\"\\theta_2\", color=RED).scale(0.7).next_to(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n            DOWN+RIGHT, buff=0.5\n        ))\n        self.play(Create(c))\n        self.wait(0.5)\n        self.play(\n            Create(line1), Create(line2),\n            Create(dot_p1), Create(dot_p3), Create(dot_p4)\n        )\n        self.wait(0.5)\n        self.play(Create(line3), Create(line4), Create(dot_p2))\n        self.wait(0.5)\n        self.play(Create(arc))\n        self.wait(0.5)\n        self.play(Create(angle1), Write(label1))\n        self.wait(0.3)\n        self.play(Create(angle2), Write(label2))\n        self.wait(1)\n        theorem = VGroup(\n            Text(\"Inscribed Angle Theorem:\", font_size=24, color=YELLOW),\n            Text(\"Angles subtending the same arc are equal\", font_size=20)\n        ).arrange(DOWN, buff=0.2)\n        theorem.to_edge(UP, buff=0.5)\n        self.play(Write(theorem))\n        self.play(FadeOut(theorem))\n        self.wait(1)\n        self.play(\n            angle1_tracker.animate.set_value(80),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            angle1_tracker.animate.set_value(45),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            angle1_tracker.animate.set_value(90),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            angle2_tracker.animate.set_value(140),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            angle2_tracker.animate.set_value(100),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            radius_tracker.animate.set_value(2.5),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            radius_tracker.animate.set_value(1.5),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            radius_tracker.animate.set_value(2.8),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            angle1_tracker.animate.set_value(70),\n            angle2_tracker.animate.set_value(115),\n            radius_tracker.animate.set_value(2.2),\n            run_time=3,\n            rate_func=smooth\n        )\n        self.wait(1)\n        final_text = Text(\n            \"The theorem holds for any circle size and vertex position!\",\n            font_size=20,\n            color=GREEN\n        ).to_edge(DOWN, buff=0.5)\n        self.play(Write(final_text))\n        self.wait(3)\nfrom manim import *",
    "InscribedAngleTheoremII": "class InscribedAngleTheoremII(Scene):\n    def construct(self):\n        block =Square(side_length=3, color=None)\n        label_sigma_xx = MathTex(r\"\\sigma_{xx}\").scale(1)\n        txx = 2\n        tyy = 1.5\n        sigma_xx = Arrow(start=ORIGIN, end=LEFT*txx, buff=0, color=YELLOW)\n        sigma_yy = Arrow(start=ORIGIN, end=DOWN*tyy, buff=0, color=YELLOW)\n        label_sigma_xx.next_to(sigma_xx.get_start(), RIGHT, buff=0.2)\n        label_sigma_yy = MathTex(r\"\\sigma_{yy}\").scale(1)\n        label_sigma_yy.next_to(block.get_top(), LEFT, buff=0.2)\n        sigma_yy.next_to(block.get_top(), LEFT, buff=0)\n        block.next_to(sigma_xx.get_end(), LEFT, buff=0)\n        block.set_fill(GRAY, opacity=1)\n        c = VGroup(block, sigma_xx, label_sigma_xx, sigma_yy, label_sigma_yy)\n        c.move_to(ORIGIN)\n        self.add(c)\n        shear_force = Arrow(start=LEFT*2 + UP*1, end=ORIGIN + UP*1, buff=0, color=YELLOW)\n        shear_force.next_to(block.get_top(), UP*1, buff=0.5)\n        self.add(shear_force)",
    "StressElement": "class StressElement(Scene):\n    def construct(self):\n        block = Square(side_length=3, color=WHITE)\n        block.set_fill(GRAY, opacity=0.5)\n        txx = 1.5\n        tyy = 1.0\n        txy = 2.0\n        offset = 0.2\n        s_xx_r = Arrow(block.get_right(), block.get_right() + RIGHT*txx, buff=0, color=YELLOW)\n        s_xx_l = Arrow(block.get_left(), block.get_left() + LEFT*txx, buff=0, color=YELLOW)\n        s_yy_t = Arrow(block.get_top(), block.get_top() + UP*tyy, buff=0, color=YELLOW)\n        s_yy_b = Arrow(block.get_bottom(), block.get_bottom() + DOWN*tyy, buff=0, color=YELLOW)\n        tau_t = Arrow(\n            block.get_top() + UP*offset + LEFT*(txy/2),\n            block.get_top() + UP*offset + RIGHT*(txy/2),\n            buff=0, color=BLUE\n        )\n        tau_b = Arrow(\n            block.get_bottom() + DOWN*offset + RIGHT*(txy/2),\n            block.get_bottom() + DOWN*offset + LEFT*(txy/2),\n            buff=0, color=BLUE\n        )\n        tau_r = Arrow(\n            block.get_right() + RIGHT*offset + DOWN*(txy/2),\n            block.get_right() + RIGHT*offset + UP*(txy/2),\n            buff=0, color=BLUE\n        )\n        tau_l = Arrow(\n            block.get_left() + LEFT*offset + UP*(txy/2),\n            block.get_left() + LEFT*offset + DOWN*(txy/2),\n            buff=0, color=BLUE\n        )\n        l_sxx = MathTex(r\"\\sigma_{xx}\").next_to(s_xx_r, RIGHT)\n        l_syy = MathTex(r\"\\sigma_{yy}\").next_to(s_yy_t, UP)\n        l_tau = MathTex(r\"\\tau_{xy}\").next_to(tau_t.get_end(), UP, buff=0.1)\n        r_tau = MathTex(r\"\\tau_{yx}\").next_to(tau_r.get_end(), RIGHT, buff=0.1)\n        element = VGroup(\n            block, s_xx_r, s_yy_t, s_yy_b,\n            tau_t, tau_b, tau_r, r_tau\n        )\n        label = VGroup(s_xx_l, l_sxx, l_syy, l_tau, r_tau)\n        element.move_to(ORIGIN)\n        label.move_to(ORIGIN)\n        self.add(element, label)\n        s_line = Line(\n            start= ORIGIN,\n            end= RIGHT*5,\n            color=RED\n        )\n        s_line.move_to(ORIGIN)\n        s_line.rotate_about_origin(PI/3)\n        self.add(s_line)",
    "StressTransformationDerivation": "class StressTransformationDerivation(Scene):\n    def construct(self):\n        theta = PI / 3\n        side = 3\n        txx, tyy, txy = 1.5, 1.0, 2.0\n        offset = 0.2\n        title = Text(\"Stress Transformation Derivation\", font_size=36)\n        title.to_edge(UP)\n        self.play(Write(title))\n        self.wait()\n        p1 = ORIGIN\n        p2 = RIGHT * side\n        p3 = UP * (side * np.tan(theta))\n        wedge = Polygon(p1, p2, p3, color=WHITE)\n        wedge.set_fill(GRAY, opacity=0.3)\n        wedge.shift(LEFT * 2)\n        arc = Arc(radius=0.8, start_angle=0, angle=theta, arc_center=p2)\n        arc.shift(LEFT * 2)\n        theta_label = MathTex(r\"\\theta\").next_to(arc, LEFT, buff=0.1).scale(0.8)\n        self.play(Create(wedge), Create(arc), Write(theta_label))\n        self.wait()\n        wedge_center = wedge.get_center()\n        s_xx_start = wedge_center + LEFT * 1.5 + UP * 0.8\n        s_xx_arrow = Arrow(s_xx_start, s_xx_start + RIGHT * txx * 0.6,\n                          buff=0, color=YELLOW, stroke_width=6)\n        s_xx_label = MathTex(r\"\\sigma_x\").next_to(s_xx_arrow, LEFT, buff=0.1).scale(0.7)\n        s_yy_start = wedge_center + DOWN * 0.8 + RIGHT * 0.5\n        s_yy_arrow = Arrow(s_yy_start, s_yy_start + UP * tyy * 0.6,\n                          buff=0, color=YELLOW, stroke_width=6)\n        s_yy_label = MathTex(r\"\\sigma_y\").next_to(s_yy_arrow, DOWN, buff=0.1).scale(0.7)\n        t_xy_start = wedge_center + DOWN * 0.8 + LEFT * 0.3\n        t_xy_arrow = Arrow(t_xy_start, t_xy_start + RIGHT * txy * 0.5,\n                          buff=0, color=ORANGE, stroke_width=6)\n        t_xy_label = MathTex(r\"\\tau_{xy}\").next_to(t_xy_arrow, DOWN, buff=0.1).scale(0.6)\n        t_xy2_start = wedge_center + LEFT * 1.5 + DOWN * 0.3\n        t_xy2_arrow = Arrow(t_xy2_start, t_xy2_start + UP * txy * 0.5,\n                           buff=0, color=ORANGE, stroke_width=6)\n        t_xy2_label = MathTex(r\"\\tau_{xy}\").next_to(t_xy2_arrow, LEFT, buff=0.1).scale(0.6)\n        stress_group = VGroup(s_xx_arrow, s_xx_label, s_yy_arrow, s_yy_label,\n                             t_xy_arrow, t_xy_label, t_xy2_arrow, t_xy2_label)\n        self.play(LaggedStart(*[GrowArrow(arr) for arr in [s_xx_arrow, s_yy_arrow, t_xy_arrow, t_xy2_arrow]], lag_ratio=0.3))\n        self.play(Write(VGroup(s_xx_label, s_yy_label, t_xy_label, t_xy2_label)))\n        self.wait()\n        hypotenuse_center = (p2 + p3) / 2 + LEFT * 2\n        normal_vec = rotate_vector(RIGHT, theta)\n        tangent_vec = rotate_vector(UP, theta)\n        sigma_n_arrow = Arrow(\n            hypotenuse_center,\n            hypotenuse_center + normal_vec * 1.2,\n            buff=0, color=RED, stroke_width=6\n        )\n        label_sn = MathTex(r\"\\sigma_n\", color=RED).next_to(sigma_n_arrow, normal_vec, buff=0.1).scale(0.8)\n        tau_nt_arrow = Arrow(\n            hypotenuse_center,\n            hypotenuse_center + tangent_vec * 1.0,\n            buff=0, color=MAROON_B, stroke_width=6\n        )\n        label_tnt = MathTex(r\"\\tau_{nt}\", color=MAROON_B).next_to(tau_nt_arrow, tangent_vec, buff=0.1).scale(0.8)\n        self.play(GrowArrow(sigma_n_arrow), GrowArrow(tau_nt_arrow))\n        self.play(Write(label_sn), Write(label_tnt))\n        self.wait(2)\n        deriv_title = Text(\"Force Balance:\", font_size=24).to_edge(RIGHT).shift(UP * 3)\n        self.play(Write(deriv_title))\n        step1 = MathTex(r\"\\sum F_n = 0\").scale(0.7)\n        step1.next_to(deriv_title, DOWN, aligned_edge=LEFT).shift(RIGHT * 0.3)\n        self.play(Write(step1))\n        self.wait()\n        step2 = MathTex(r\"\\sigma_n \\cdot dA = \\sigma_x \\cdot dA \\sin\\theta \\cos\\theta\").scale(0.6)\n        step2.next_to(step1, DOWN, aligned_edge=LEFT, buff=0.3)\n        step2_cont = MathTex(r\"+ \\sigma_y \\cdot dA \\sin\\theta \\cos\\theta\").scale(0.6)\n        step2_cont.next_to(step2, DOWN, aligned_edge=LEFT, buff=0.1)\n        step2_cont2 = MathTex(r\"+ \\tau_{xy} \\cdot dA (\\cos^2\\theta - \\sin^2\\theta)\").scale(0.6)\n        step2_cont2.next_to(step2_cont, DOWN, aligned_edge=LEFT, buff=0.1)\n        self.play(Write(step2))\n        self.wait()\n        self.play(Write(step2_cont))\n        self.wait()\n        self.play(Write(step2_cont2))\n        self.wait(2)\n        step3_label = Text(\"Using: \", font_size=20).next_to(step2_cont2, DOWN, aligned_edge=LEFT, buff=0.4)\n        step3 = MathTex(r\"\\sin\\theta\\cos\\theta = \\frac{1}{2}\\sin 2\\theta\").scale(0.55)\n        step3.next_to(step3_label, RIGHT, buff=0.1)\n        step3b = MathTex(r\"\\cos^2\\theta - \\sin^2\\theta = \\cos 2\\theta\").scale(0.55)\n        step3b.next_to(step3, DOWN, aligned_edge=LEFT, buff=0.1)\n        self.play(Write(step3_label), Write(step3))\n        self.wait()\n        self.play(Write(step3b))\n        self.wait(2)\n        self.play(FadeOut(step2, step2_cont, step2_cont2, step3_label, step3, step3b))\n        step4_label = Text(\"Normal Stress:\", font_size=22, color=RED).next_to(step1, DOWN, aligned_edge=LEFT, buff=0.5)\n        step4 = MathTex(\n            r\"\\sigma_n = \\frac{\\sigma_x + \\sigma_y}{2}\",\n            color=RED\n        ).scale(0.7)\n        step4.next_to(step4_label, DOWN, aligned_edge=LEFT, buff=0.2)\n        step4b = MathTex(\n            r\"+ \\frac{\\sigma_x - \\sigma_y}{2}\\cos 2\\theta\",\n            color=RED\n        ).scale(0.7)\n        step4b.next_to(step4, DOWN, aligned_edge=LEFT, buff=0.1)\n        step4c = MathTex(\n            r\"+ \\tau_{xy}\\sin 2\\theta\",\n            color=RED\n        ).scale(0.7)\n        step4c.next_to(step4b, DOWN, aligned_edge=LEFT, buff=0.1)\n        self.play(Write(step4_label))\n        self.play(Write(step4))\n        self.wait()\n        self.play(Write(step4b))\n        self.wait()\n        self.play(Write(step4c))\n        self.wait(2)\n        step5_label = Text(\"Shear Stress:\", font_size=22, color=MAROON_B).next_to(step4c, DOWN, aligned_edge=LEFT, buff=0.5)\n        step5 = MathTex(\n            r\"\\tau_{nt} = -\\frac{\\sigma_x - \\sigma_y}{2}\\sin 2\\theta\",\n            color=MAROON_B\n        ).scale(0.7)\n        step5.next_to(step5_label, DOWN, aligned_edge=LEFT, buff=0.2)\n        step5b = MathTex(\n            r\"+ \\tau_{xy}\\cos 2\\theta\",\n            color=MAROON_B\n        ).scale(0.7)\n        step5b.next_to(step5, DOWN, aligned_edge=LEFT, buff=0.1)\n        self.play(Write(step5_label))\n        self.play(Write(step5))\n        self.wait()\n        self.play(Write(step5b))\n        self.wait(2)\n        box = SurroundingRectangle(VGroup(step4_label, step4, step4b, step4c, step5_label, step5, step5b),\n                                   color=BLUE, buff=0.2)\n        self.play(Create(box))\n        self.wait(2)\n        summary = Text(\"Stress Transformation Complete!\", font_size=28, color=GREEN)\n        summary.to_edge(DOWN)\n        self.play(Write(summary))\n        self.wait(3)\n        self.play(FadeOut(Group(*self.mobjects)))\n        self.wait()",
    "StressTransformation": "class StressTransformation(Scene):\n    def construct(self):\n        theta = PI / 3\n        side = 3\n        txx, tyy, txy = 1.5, 1.0, 1.2\n        offset = 0.2\n        p_origin = ORIGIN\n        p_right = RIGHT * side\n        p_top = UP * (side * np.tan(theta))\n        wedge = Polygon(p_origin, p_right, p_top, color=WHITE, stroke_width=2)\n        wedge.set_fill(GRAY, opacity=0.3)\n        hyp_mid = (p_right + p_top) / 2\n        normal_dir = rotate_vector(RIGHT, theta)\n        tangent_dir = rotate_vector(UP, theta)\n        s_n = Arrow(hyp_mid, hyp_mid + normal_dir * 1.5, buff=0, color=RED)\n        t_nt = Arrow(hyp_mid, hyp_mid + tangent_dir * 1.2, buff=0, color=MAROON)\n        l_sn = MathTex(r\"\\sigma_n\").next_to(s_n, normal_dir, buff=0.1)\n        l_tnt = MathTex(r\"\\tau_{nt}\").next_to(t_nt, tangent_dir, buff=0.1)\n        s_xx_v = Arrow(p_origin + LEFT*offset, p_origin + LEFT*(txx+offset), buff=0, color=YELLOW)\n        s_xx_v.shift(UP * (p_top[1]/2))\n        l_xx = MathTex(r\"\\sigma_{xx}\").next_to(s_xx_v, LEFT)\n        s_yy_h = Arrow(p_origin + DOWN*offset, p_origin + DOWN*(tyy+offset), buff=0, color=YELLOW)\n        s_yy_h.shift(RIGHT * (side/2))\n        l_yy = MathTex(r\"\\sigma_{yy}\").next_to(s_yy_h, DOWN)\n        tau_h = Arrow(p_origin + DOWN*offset*2, p_origin + DOWN*offset*2 + RIGHT*1.5, buff=0, color=BLUE)\n        tau_h.shift(RIGHT * (side/2 - 0.75))\n        arc = Arc(radius=0.7, start_angle=0, angle=theta, arc_center=p_right)\n        l_theta = MathTex(r\"\\theta\").next_to(arc, LEFT, buff=0.1).scale(0.8)\n        eq = MathTex(\n            r\"\\sigma_n = \\sigma_x \\cos^2\\theta + \\sigma_y \\sin^2\\theta + 2\\tau_{xy}\\sin\\theta\\cos\\theta\"\n        ).scale(0.7).to_edge(DOWN)\n        derivation = VGroup(wedge, s_n, t_nt, l_sn, l_tnt, s_xx_v, l_xx, s_yy_h, l_yy, tau_h, arc, l_theta)\n        derivation.move_to(ORIGIN).scale(0.9)\n        self.add(derivation, eq)"
}