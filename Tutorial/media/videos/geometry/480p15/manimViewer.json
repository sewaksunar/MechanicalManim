{
    "pythagorean_theorem": "class pythagorean_theorem(Scene):\n    def cad_dimension(self, start, end, label_text, offset_val=0.5, scale=0.7,\n                            arrow_size=0.15, ext_line_extension=0.1):\n        \"\"\"Creates a CAD-style dimension with extension lines, arrows, and text.\"\"\"\n        p1 = Point(float(start[0]), float(start[1]))\n        p2 = Point(float(end[0]), float(end[1]))\n        main_seg = Segment(p1, p2)\n        dist = float(main_seg.length)\n        if dist == 0:\n            return VGroup()\n        midpoint_sp = main_seg.midpoint\n        main_line = SpLine(p1, p2)\n        perp_line = main_line.perpendicular_line(midpoint_sp)\n        perp_dir = perp_line.direction.unit\n        perp_dir_np = np.array([float(perp_dir.x), float(perp_dir.y), 0])\n        if offset_val < 0:\n            perp_dir_np = -perp_dir_np\n        offset_distance = abs(offset_val)\n        dim_start = start + perp_dir_np * offset_distance\n        dim_end = end + perp_dir_np * offset_distance\n        direction = end - start\n        unit_dir = direction / np.linalg.norm(direction)\n        ext_line_1 = Line(\n            start - perp_dir_np * 0.1,\n            dim_start + perp_dir_np * ext_line_extension,\n            color=GRAY,\n            stroke_width=1\n        )\n        ext_line_2 = Line(\n            end - perp_dir_np * 0.1,\n            dim_end + perp_dir_np * ext_line_extension,\n            color=GRAY,\n            stroke_width=1\n        )\n        dim_line = Line(dim_start, dim_end, color=GRAY, stroke_width=2)\n        arrow_1 = Arrow(\n            dim_start + unit_dir * arrow_size,\n            dim_start,\n            buff=0,\n            color=GRAY,\n            stroke_width=2,\n            max_tip_length_to_length_ratio=1,\n            tip_length=arrow_size\n        )\n        arrow_2 = Arrow(\n            dim_end - unit_dir * arrow_size,\n            dim_end,\n            buff=0,\n            color=GRAY,\n            stroke_width=2,\n            max_tip_length_to_length_ratio=1,\n            tip_length=arrow_size\n        )\n        label = MathTex(label_text).scale(scale)\n        angle = float(sp.atan2(p2.y - p1.y, p2.x - p1.x))\n        if PI/2 < angle <= PI or -PI <= angle < -PI/2:\n            angle += PI\n        label.rotate(angle)\n        midpoint = (dim_start + dim_end) / 2\n        label.move_to(midpoint + perp_dir_np * 0.3)\n        return VGroup(ext_line_1, ext_line_2, dim_line, arrow_1, arrow_2, label)\n    def construct(self):\n        a, b = 3, 4\n        C_np = np.array([0, 0, 0])\n        A_np = np.array([b, 0, 0])\n        B_np = np.array([0, a, 0])\n        triangle_shape = Polygon(\n            C_np,\n            A_np,\n            B_np,\n            color=BLUE\n        )\n        labelC = MathTex(\"C\")\n        labelC.next_to(C_np, DOWN+LEFT)\n        labelA = MathTex(\"A\")\n        labelA.next_to(A_np, DOWN+RIGHT)\n        labelB = MathTex(\"B\")\n        labelB.next_to(B_np, UP+LEFT)\n        dotA = Dot(A_np)\n        dotB = Dot(B_np)\n        dotC = Dot(C_np)\n        triangle = VGroup(triangle_shape, dotA, labelA, dotB, labelB, dotC, labelC)\n        title = Title(f\"Pythagoras Theorem\")\n        self.add(title)\n        self.add(triangle.move_to(ORIGIN))\n        self.play(Create(triangle), run_time=3)\n        vertices = triangle_shape.get_vertices()\n        C_actual = vertices[0]\n        A_actual = vertices[1]\n        B_actual = vertices[2]\n        c_dim = self.cad_dimension(A_actual, B_actual, \"c\", offset_val=-0.3)\n        a_dim = self.cad_dimension(C_actual, B_actual, \"a\", offset_val=-0.3)\n        b_dim = self.cad_dimension(C_actual, A_actual, \"b\", offset_val=-0.3)\n        full_diagram = VGroup(triangle, c_dim, a_dim, b_dim)\n        self.play(Create(c_dim), run_time=1)\n        self.play(Create(a_dim), run_time=1)\n        self.play(Create(b_dim), run_time=1)\n        self.play(full_diagram.animate.move_to(LEFT*3), run_time=1)\n        anno_c = MathTex(\n            r\"c \\ \\text{is the hypotenous}\"\n        )\n        anno_a = MathTex(\n            r\"a \\ \\text{is the perpendicular}\"\n        )\n        anno_b = MathTex(\n            r\"b \\ \\text{is the base}\"\n        )\n        self.play(AnimationGroup(Indicate(c_dim, scale_factor=1),Indicate(labelC), Write(anno_c.move_to(RIGHT*3))))\n        self.play(AnimationGroup(Indicate(a_dim, scale_factor=1),Indicate(labelA), Write(anno_a.next_to(RIGHT*3, DOWN))))\n        self.play(AnimationGroup(Indicate(b_dim, scale_factor=1),Indicate(labelB), Write(anno_b.next_to(RIGHT*3, DOWN*3))))\n        anno = VGroup(anno_a, anno_b, anno_c)\n        self.play(FadeOut(anno))\n        equ = MathTex(r\"c^2 = a^2 + b^2\")\n        self.play(Write(equ.move_to(RIGHT*3)))\n        self.wait(2)",
    "InscribedAngleTheoremI": "class InscribedAngleTheoremI(Scene):\n    def construct(self):\n        c = Circle(radius=2)\n        c.move_to(ORIGIN)\n        p1 = c.point_at_angle(60*DEGREES)\n        p2 = c.point_at_angle(120*DEGREES)\n        p3 = c.point_at_angle(230*DEGREES)\n        p4 = c.point_at_angle(330*DEGREES)\n        self.play(Create(c))\n        line1 = Line(p4, p1)\n        line2 = Line(p1, p3)\n        cline1 = VGroup(Dot(p4), line1, Dot(p1), line2, Dot(p3))\n        line3 = Line(p3, p2)\n        line4 = Line(p2, p4)\n        cline2 = VGroup(Dot(p3), line3, Dot(p2), line4, Dot(p4))\n        self.play(Create(cline1))\n        self.play(Create(cline2))\n        arc = TangentialArc(line1, line2, radius=2.25, corner=(1, 1), color=TEAL)\n        self.add(arc, line1, line2)\n        self.wait(5)"
}