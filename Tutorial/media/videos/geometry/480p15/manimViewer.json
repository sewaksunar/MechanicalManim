{
    "pythagorean_theorem": "class pythagorean_theorem(Scene):\n    def cad_dimension(self, start, end, label_text, offset_val=0.5, scale=0.7,\n                            arrow_size=0.15, ext_line_extension=0.1):\n        \"\"\"Creates a CAD-style dimension with extension lines, arrows, and text.\"\"\"\n        p1 = Point(float(start[0]), float(start[1]))\n        p2 = Point(float(end[0]), float(end[1]))\n        main_seg = Segment(p1, p2)\n        dist = float(main_seg.length)\n        if dist == 0:\n            return VGroup()\n        midpoint_sp = main_seg.midpoint\n        main_line = SpLine(p1, p2)\n        perp_line = main_line.perpendicular_line(midpoint_sp)\n        perp_dir = perp_line.direction.unit\n        perp_dir_np = np.array([float(perp_dir.x), float(perp_dir.y), 0])\n        if offset_val < 0:\n            perp_dir_np = -perp_dir_np\n        offset_distance = abs(offset_val)\n        dim_start = start + perp_dir_np * offset_distance\n        dim_end = end + perp_dir_np * offset_distance\n        direction = end - start\n        unit_dir = direction / np.linalg.norm(direction)\n        ext_line_1 = Line(\n            start - perp_dir_np * 0.1,\n            dim_start + perp_dir_np * ext_line_extension,\n            color=GRAY,\n            stroke_width=1\n        )\n        ext_line_2 = Line(\n            end - perp_dir_np * 0.1,\n            dim_end + perp_dir_np * ext_line_extension,\n            color=GRAY,\n            stroke_width=1\n        )\n        dim_line = Line(dim_start, dim_end, color=GRAY, stroke_width=2)\n        arrow_1 = Arrow(\n            dim_start + unit_dir * arrow_size,\n            dim_start,\n            buff=0,\n            color=GRAY,\n            stroke_width=2,\n            max_tip_length_to_length_ratio=1,\n            tip_length=arrow_size\n        )\n        arrow_2 = Arrow(\n            dim_end - unit_dir * arrow_size,\n            dim_end,\n            buff=0,\n            color=GRAY,\n            stroke_width=2,\n            max_tip_length_to_length_ratio=1,\n            tip_length=arrow_size\n        )\n        label = MathTex(label_text).scale(scale)\n        angle = float(sp.atan2(p2.y - p1.y, p2.x - p1.x))\n        if PI/2 < angle <= PI or -PI <= angle < -PI/2:\n            angle += PI\n        label.rotate(angle)\n        midpoint = (dim_start + dim_end) / 2\n        label.move_to(midpoint + perp_dir_np * 0.3)\n        return VGroup(ext_line_1, ext_line_2, dim_line, arrow_1, arrow_2, label)\n    def construct(self):\n        a, b = 3, 4\n        C_np = np.array([0, 0, 0])\n        A_np = np.array([b, 0, 0])\n        B_np = np.array([0, a, 0])\n        triangle_shape = Polygon(\n            C_np,\n            A_np,\n            B_np,\n            color=BLUE\n        )\n        labelC = MathTex(\"C\")\n        labelC.next_to(C_np, DOWN+LEFT)\n        labelA = MathTex(\"A\")\n        labelA.next_to(A_np, DOWN+RIGHT)\n        labelB = MathTex(\"B\")\n        labelB.next_to(B_np, UP+LEFT)\n        dotA = Dot(A_np)\n        dotB = Dot(B_np)\n        dotC = Dot(C_np)\n        triangle = VGroup(triangle_shape, dotA, labelA, dotB, labelB, dotC, labelC)\n        title = Title(f\"Pythagoras Theorem\")\n        self.add(title)\n        self.add(triangle.move_to(ORIGIN))\n        self.play(Create(triangle), run_time=3)\n        vertices = triangle_shape.get_vertices()\n        C_actual = vertices[0]\n        A_actual = vertices[1]\n        B_actual = vertices[2]\n        c_dim = self.cad_dimension(A_actual, B_actual, \"c\", offset_val=-0.3)\n        a_dim = self.cad_dimension(C_actual, B_actual, \"a\", offset_val=-0.3)\n        b_dim = self.cad_dimension(C_actual, A_actual, \"b\", offset_val=-0.3)\n        full_diagram = VGroup(triangle, c_dim, a_dim, b_dim)\n        self.play(Create(c_dim), run_time=1)\n        self.play(Create(a_dim), run_time=1)\n        self.play(Create(b_dim), run_time=1)\n        self.play(full_diagram.animate.move_to(LEFT*3), run_time=1)\n        anno_c = MathTex(\n            r\"c \\ \\text{is the hypotenous}\"\n        )\n        anno_a = MathTex(\n            r\"a \\ \\text{is the perpendicular}\"\n        )\n        anno_b = MathTex(\n            r\"b \\ \\text{is the base}\"\n        )\n        self.play(AnimationGroup(Indicate(c_dim, scale_factor=1),Indicate(labelC), Write(anno_c.move_to(RIGHT*3))))\n        self.play(AnimationGroup(Indicate(a_dim, scale_factor=1),Indicate(labelA), Write(anno_a.next_to(RIGHT*3, DOWN))))\n        self.play(AnimationGroup(Indicate(b_dim, scale_factor=1),Indicate(labelB), Write(anno_b.next_to(RIGHT*3, DOWN*3))))\n        anno = VGroup(anno_a, anno_b, anno_c)\n        self.play(FadeOut(anno))\n        equ = MathTex(r\"c^2 = a^2 + b^2\")\n        self.play(Write(equ.move_to(RIGHT*3)))\n        self.wait(2)",
    "InscribedAngleTheoremI": "class InscribedAngleTheoremI(Scene):\n    def construct(self):\n        radius_tracker = ValueTracker(2)\n        angle1_tracker = ValueTracker(60)\n        angle2_tracker = ValueTracker(120)\n        angle3_tracker = ValueTracker(230)\n        angle4_tracker = ValueTracker(330)\n        c = always_redraw(lambda: Circle(\n            radius=radius_tracker.get_value(),\n            color=WHITE\n        ).move_to(ORIGIN))\n        dot_p1 = always_redraw(lambda: Dot(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n            color=YELLOW\n        ))\n        dot_p2 = always_redraw(lambda: Dot(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n            color=YELLOW\n        ))\n        dot_p3 = always_redraw(lambda: Dot(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle3_tracker.get_value()*DEGREES),\n            color=YELLOW\n        ))\n        dot_p4 = always_redraw(lambda: Dot(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle4_tracker.get_value()*DEGREES),\n            color=YELLOW\n        ))\n        line1 = always_redraw(lambda: Line(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle3_tracker.get_value()*DEGREES),\n            color=BLUE\n        ))\n        line2 = always_redraw(lambda: Line(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle4_tracker.get_value()*DEGREES),\n            color=BLUE\n        ))\n        line3 = always_redraw(lambda: Line(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle3_tracker.get_value()*DEGREES),\n            color=RED\n        ))\n        line4 = always_redraw(lambda: Line(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle4_tracker.get_value()*DEGREES),\n            color=RED\n        ))\n        arc = always_redraw(lambda: Arc(\n            radius=radius_tracker.get_value(),\n            start_angle=angle3_tracker.get_value()*DEGREES,\n            angle=(angle4_tracker.get_value() - angle3_tracker.get_value())*DEGREES,\n            color=GREEN,\n            stroke_width=6\n        ))\n        angle1 = always_redraw(lambda: Angle(\n            Line(\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle3_tracker.get_value()*DEGREES)\n            ),\n            Line(\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle4_tracker.get_value()*DEGREES)\n            ),\n            radius=0.5,\n            color=YELLOW\n        ))\n        angle2 = always_redraw(lambda: Angle(\n            Line(\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle3_tracker.get_value()*DEGREES)\n            ),\n            Line(\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n                Circle(radius=radius_tracker.get_value()).point_at_angle(angle4_tracker.get_value()*DEGREES)\n            ),\n            radius=0.5,\n            color=YELLOW\n        ))\n        label1 = always_redraw(lambda: MathTex(r\"\\theta_1\", color=BLUE).scale(0.7).next_to(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle1_tracker.get_value()*DEGREES),\n            DOWN, buff=0.3\n        ))\n        label2 = always_redraw(lambda: MathTex(r\"\\theta_2\", color=RED).scale(0.7).next_to(\n            Circle(radius=radius_tracker.get_value()).point_at_angle(angle2_tracker.get_value()*DEGREES),\n            DOWN, buff=0.3\n        ))\n        self.play(Create(c))\n        self.wait(0.5)\n        self.play(\n            Create(line1), Create(line2),\n            Create(dot_p1), Create(dot_p3), Create(dot_p4)\n        )\n        self.wait(0.5)\n        self.play(Create(line3), Create(line4), Create(dot_p2))\n        self.wait(0.5)\n        self.play(Create(arc))\n        self.wait(0.5)\n        self.play(Create(angle1), Write(label1))\n        self.wait(0.3)\n        self.play(Create(angle2), Write(label2))\n        self.wait(1)\n        theorem = VGroup(\n            Text(\"Inscribed Angle Theorem:\", font_size=24, color=YELLOW),\n            Text(\"Angles subtending the same arc are equal\", font_size=20)\n        ).arrange(DOWN, buff=0.2)\n        theorem.to_edge(UP, buff=0.5)\n        self.play(Write(theorem))\n        self.wait(1)\n        self.play(\n            angle1_tracker.animate.set_value(80),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            angle1_tracker.animate.set_value(45),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            angle1_tracker.animate.set_value(90),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            angle2_tracker.animate.set_value(140),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            angle2_tracker.animate.set_value(100),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            radius_tracker.animate.set_value(2.5),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            radius_tracker.animate.set_value(1.5),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            radius_tracker.animate.set_value(2.8),\n            run_time=2,\n            rate_func=smooth\n        )\n        self.wait(0.5)\n        self.play(\n            angle1_tracker.animate.set_value(70),\n            angle2_tracker.animate.set_value(115),\n            radius_tracker.animate.set_value(2.2),\n            run_time=3,\n            rate_func=smooth\n        )\n        self.wait(1)\n        final_text = Text(\n            \"The theorem holds for any circle size and vertex position!\",\n            font_size=20,\n            color=GREEN\n        ).to_edge(DOWN, buff=0.5)\n        self.play(Write(final_text))\n        self.wait(3)"
}